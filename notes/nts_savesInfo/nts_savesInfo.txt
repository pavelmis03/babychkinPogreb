saves\save_cmn - общая инфа:
					сохранение количества просмотров истории
					
1) сохранения создаются в папке: saves/
2) 
3) 
	
ПОДРОБНЕЕ СМОТРИ В ДИЗДОКЕ
лень второй раз писать)

ВАЖНО
0) ВАЖНО: при создании объекта, который должен сохраняться и при этом может перемещаться по комнатам, 
	необходимо создать для него постоянный контроллер c need_sv = 2 (как, например, obj_ctrl_gm_playerStatus),
	и сохранять именно его
1) при добавлении сохраняющегося объекта лучше постараться не использовать массивы
2) структуры ds нужно разбирать в событии UE0, как в объекте obj_ctrl_gm_inv
3) nonSvVar = ["var1, "var2"] - массив переменных, которые не нужно сохранять. Обязательно внести туда init
4) порядок работы сохранения и загрузки: 
	1) контроллер сохранений при начале новой игры создает фиктивное сохранение (папку), в нее добавляет
		все объекты с need_sv = 1 в файл, называющийся по имени комнаты каждый раз при покидании комнаты
		Сигнал на сохранение отдают специальные объекты (двери в основном), поэтому некоторые комнаты
		не сохраняются. Также файл сохранения комнаты автоматически удаляется после прохода по 
		всем объектам, если не было найдено объектов с need_sv = 1. Объекты с need_sv = 2 сохраняются 
		в отдельный файл - travelersObj.txt так же по сигналу. Но они сохраняются все 
		и полностью всегда, когда был отдан сигнал на сохранение. Файл перезаписывается т.к. 
		эти объекты все постоянные и всегда перемещаются за игроком. Для сохранения комнаты 
		используется скрипт scr_sv_svRm, который проходит по всем экземплярам в комнате, если 
		эти экзмепляры имеют need_sv = 1, они сохраняются в файл комнаты, если need_sv = 2, в 
		файл travelersObj.txt. При сохранении скрипт проходит по всем переменным экземпляра, кроме
		переменных, указанных в nonSvVar, и, определяя тип переменной с помощью скрипта	scr_var_typeOf
		сохраняет переменные в файл следующим образом: varName = varVal = typeOfVar, чтобы 
		потом было удобно разбирать файл.
		Контроллер перемещений также изменился: теперь при необходимости перейти в другую 
		комнату ему в массив next_rm_list_ добавляется комната назначения и ставится задержка 
		перемещения ctrl_mv_rmChangeDelay, чтобы контроллер сохранений успел сохранить игру.
	2) после того, как игрок сохранится в терминале, контроллер сохранений добавит скриншот в 
		папку текущего сохранения, сделает его действительным saveValid = 0 в файле saveInfo.ini,
		добавит инфу о квесте, дате, локации, имени родителя и т.д. и после этого создаст новое 
		фиктивное сохранение с номером на 1 больше текущего. Также он назначает данное сохранение
		в файл gameInfo.ini, как последнее !действительное! сохранение
	3) при выходе из игры контроллером игры подается сигнал на очистку всех переменных, 
		связанных с текущим сохранением
	4) когда мы заходим в меню загрузок, КЗ (контроллер загрузок) проверяет, что существует
		хотя бы	одна папка игры, затем сохраняет все найденные папки игры в массив игр.
		Если папки игр есть, контроллер загрузок пытается найти последнюю игру и сохр. 
		из файла gameInfo.ini, если находит, загружает указанную в нем игру, если нет, ставит 
		последнюю игру и последнее сохранение в фокус. 
		Когда загружаются сохранения игры, КЗ запускает скрипт scr_ld_findSvPaths, который 
		проходит по всем сохранениям в папке игры и добавляет их в массив путей сохранений
		ctrl_ldGm_svPaths, также он удаляет все фиктивные сохранения, сначала запоминая их, 
		а потом вызывая скрипт удаления сохранения. После того, как сформирован ctrl_ldGm_svPaths 
		КЗ настраивает меню и запускает scr_ld_createLdBtn, который создает кнопки-загрузчики. 
		Этот же скрипт вызывается при перелистывании страницы и игры, при удалении игры. 
		При удалении сохранения вызывается скрипт scr_ld_delSv, который удаляет папку сохранения,
		а потом проверяет, было ли это последнее в ветке сохранение, и удаляет ветку,
		было ли последнее в игре и вызывает скрипт удаления игры scr_ld_delGm. Если это просто 
		сохранение, последнее в ветке, после диалога о желании удалить сохранение, 
		оно удаляется, пересоздаются кнопки-загрузчики. Если это сохранение, содержащее в себе 
		ветвь, выводится другой диалог, сообщающий о том, что будут удалены и другие сохранения. 
		При удалении игры вызывается scr_ld_delGm, который удаляет игру и ставит в фокус последнюю
		из оставшихся, настраивает меню, если это была последняя игра, вызывает диалог начала новой игры
	5) После выбора сохранения, нажатия кнопки ,,загрузить,, и согласия с диалогом, загружается игра.
		Контроллерам игры КИ и сохранений КС Кзагрузок назначает действия по загрузке игры,
		КС передается путь до папки выбранного сохранения, а сам отмечает загруженное сохранение
		в gameInfo.ini, как последнее загруженное. КИ создает не сохраняющиеся контроллеры 
		и переходит в комнату, сохраненную в файле saveInfo.ini по пути папки сохранения, если 
		активированы пиксели, сначала переходит в них. КС загружает игру, проходя по всем файлам в папке 
		сохранения. Если это файл информации о сохранении, загружает игровую дату и квест, если 
		файл сохранения комнаты, добавляет комнату в массив, ctrl_sv_ldRms, который потом будет
		служить для индикации необходимости загрузки комнаты и для обновления комнат, которые 
		в этом массиве не содержаться (а значит, если они были изменены, то в другой игровой 
		сессии или сохранении, поэтому их нужно вернуть в первоначальное состояние), если
		это файл перемещающихся объектов, сразу создает их, вызывая скрипт scr_ld_createObjFromFile.
		После этого выбирается имя и путь для папки фиктивного сохранения: сначала проверяется, последняя это
		папка в текущем каталоге, если да, то создается сохранение с индексом на 1 больше, иначе
		создается ветвь (с индексом на 1 больше последней в сохранении, если они там есть, иначе первая
		и в ней создается первое сохранение. Последние папки находятся с помощью скрипта scr_file_findLast, 
		который просто проходит по всем папкам в указанном каталоге с помощью функции file_find.
		После этого вызывается событие, где создается фиктивное сохранение.
	6) scr_ld_createObjFromFile: читает переданный файл сохранения и, проходя по каждой строке, 
		создает структуру, по которой в конце чтения экземпляра создает экземпляр, передавая в 
		него правильные значения переменных. Есть некоторые особенности работы со структурами DS
		(см. UE0 obj_ctrl_gm_inv). Использует скрипт scr_var_convVal, который преобразует строку
		в переменную по переданному типу, который в свою очередь использует скрипты 
		scr_arr_readFromStr для чтения массива из строки (есть особенности, см. скрипт 
		scr_arr_readFromStr) и скрипт scr_struct_readFromStr для чтения структур
	7) при перемещении по комнатам контроллер сохранений проверяет, если ли комната в массиве 
		ctrl_sv_ldRms, если нет, комната перезагружается, при этом сохраняется ее постоянность, 
		а потом добавляется в массив ctrl_sv_ldRms, чтобы больше ее не перезагружать. 
		Потом проверяется, есть ли комната в массиве ctrl_sv_ldRmsTmp, если да, это значит, 
		что данная комната была сохранена, и ее надо загрузить (перед загрузкой также делается
		перезагрузка с сохранением постоянности для сброса изменений, сделанных в других 
		игровых сессиях или сохранениях), для этого вызывается 
		скрипт scr_ctrl_sv_ldRm, а комната удаляется из массива ctrl_sv_ldRmsTmp
	8) Также контроллер сохранений записывает информацию о последних игре и сохранении в gameInfo.ini,
		сохраняет дату, время (игровые и реальные) и др. информацию о сохраненнии в событии 
		сохранения игры. Сохраняет родительское сохранение в событии создания фиктивного сохранения
	9) scr_ctrl_sv_ldRm: если файл сохранения комнаты существует, удаляет в комнате все объекты, 
		с need_cv = 1 и создает их заново, вызывая скрипт scr_ld_createObjFromFile














